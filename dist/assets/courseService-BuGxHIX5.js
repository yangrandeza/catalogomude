const n="http://192.168.1.11:3001/api",r=o=>{if(console.log("[constructFullFileUrl] Input filePath:",o,"API_BASE_URL:",n),!o)return console.log("[constructFullFileUrl] Returning null for empty filePath"),null;let e=o.replace(/\\/g,"/");if(e=e.split("/").map(i=>i==="uploads"?i:encodeURIComponent(i)).join("/"),e.startsWith("http")||e.startsWith("https:")||e.startsWith("data:"))return console.log("[constructFullFileUrl] normalizedAndEncodedPath already a full URL or data URL:",e),e;const a=n.replace("/api",""),t=e.startsWith("/")?`${a}${e}`:`${a}/${e}`;return console.log("[constructFullFileUrl] Constructed URL:",t),t},l=async()=>{const o=await fetch(`${n}/courses`);if(!o.ok){const s=await o.json().catch(()=>({message:"Failed to fetch courses"}));throw new Error(s.message||"Failed to fetch courses")}return(await o.json()).map(s=>({...s,coverImage:r(s.coverImage),scormFile:r(s.scormFile)}))},d=async o=>{const e=await fetch(`${n}/courses/${o}`);if(!e.ok){if(e.status===404)return;const c=await e.json().catch(()=>({message:`Failed to fetch course ${o}`}));throw new Error(c.message||`Failed to fetch course ${o}`)}const s=await e.json();return{...s,coverImage:r(s.coverImage),scormFile:r(s.scormFile)}},m=async o=>{const e=new FormData;e.append("name",o.name),o.description&&e.append("description",o.description),o.coverImage&&e.append("coverImage",o.coverImage),o.scormFile&&e.append("scormFile",o.scormFile);const s=await fetch(`${n}/courses`,{method:"POST",body:e});if(!s.ok){const t=await s.json().catch(()=>({message:"Failed to create course"}));throw new Error(t.message||"Failed to create course")}const a=(await s.json()).course;return{...a,coverImage:r(a.coverImage),scormFile:r(a.scormFile)}},u=async(o,e)=>{const s=new FormData;s.append("name",e.name),e.description&&s.append("description",e.description),e.coverImage instanceof File&&s.append("coverImage",e.coverImage),e.scormFile instanceof File&&s.append("scormFile",e.scormFile);const c=await fetch(`${n}/courses/${o}`,{method:"PUT",body:s});if(!c.ok){const i=await c.json().catch(()=>({message:"Failed to update course"}));throw new Error(i.message||"Failed to update course")}const t=(await c.json()).course;return{...t,coverImage:r(t.coverImage),scormFile:r(t.scormFile)}},p=async o=>{const e=await fetch(`${n}/courses/${o}`,{method:"DELETE"});if(!e.ok){const s=await e.json().catch(()=>({message:"Failed to delete course"}));throw new Error(s.message||"Failed to delete course")}};export{d as a,m as c,p as d,l as g,u};
